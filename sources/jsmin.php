<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2012

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/**
 * jsmin.php - PHP implementation of Douglas Crockford's JSMin.
 *
 * This is pretty much a direct port of jsmin.c to PHP with just a few
 * PHP-specific performance tweaks. Also, whereas jsmin.c reads from stdin and
 * outputs to stdout, this library accepts a string as input and returns another
 * string as output.
 *
 * PHP 5 or higher is required.
 *
 * Permission is hereby granted to use this version of the library under the
 * same terms as jsmin.c, which has the following license:
 *
 * --
 * Copyright (c) 2002 Douglas Crockford  (www.crockford.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * The Software shall be used for Good, not Evil.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * --
 *
 * @author Ryan Grove <ryan@wonko.com>
 * @copyright 2002 Douglas Crockford <douglas@crockford.com> (jsmin.c)
 * @copyright 2008 Ryan Grove <ryan@wonko.com> (PHP port)
 * @license http://opensource.org/licenses/mit-license.php MIT License
 * @version 1.1.1 (2008-03-02)
 * @link http://code.google.com/p/jsmin-php/
 */

/*
Licensing note by ocProducts...

The "Good, not Evil" bit was inserted to this MIT-derived licence by Douglas Crockford, as a joke [reference: his talk, "The JSON Saga"].
Therefore we can interpret this in a very moderate way. Also it's definition is clear, so no one could rule a particular usage as evil as there is no legal definition of evil.
Lastly, this cogent point has been made:
"The terms of Evil are not outlined. And to use license to stop freedom is Evil [in the spirit of the original MIT licence the statement is written into], therefore the only Evil is using the software to stop its free use..."
*/

class JSMin
{
	var $a = '';
	var $b = '';
	var $input = '';
	var $inputIndex = 0;
	var $inputLength = 0;
	var $lookAhead = NULL;
	var $output = '';

	// -- Public Instance Methods ------------------------------------------------

	/**
	 * Constructor function
	 *
	 * @param 	string		Javascript to minimise
	 */
	function JSMin($input)
	{
		$this->input = str_replace("\r\n", "\n", $input);
		$this->inputLength = strlen($this->input);
	}

	// -- Protected Instance Methods ---------------------------------------------

	/**
	 * Handle internal parse situation
	 *
	 * @param 	integer		Action type
	 * @return	?array		Error (NULL: no error)
	 */
	function action($d)
	{
		$chr_lf=10;
		$chr_space=32;

		switch($d)
		{
			case 1:
				$this->output .= $this->a;

			case 2:
				$this->a = $this->b;

				if ($this->a === "'" || $this->a === '"')
				{
					while (true)
					{
						$this->output .= $this->a;
						$this->a			 = $this->get();

						if ($this->a === NULL)
						{
							return NULL;
						}

						if ($this->a === $this->b)
						{
							break;
						}

						if (ord($this->a) <= $chr_lf)
						{
							return array('Unterminated string literal.');
						}

						if ($this->a === '\\')
						{
							$this->output .= $this->a;
							$this->a			 = $this->get();
						}
					}
				}

			case 3:
				$this->b = $this->next();
				if (is_array($this->b)) return $this->b;

				if ($this->b === '/' && (
						$this->a === '(' || $this->a === ',' || $this->a === '=' ||
						$this->a === ':' || $this->a === '[' || $this->a === '!' ||
						$this->a === '&' || $this->a === '|' || $this->a === '?'))
				{

					$this->output .= $this->a . $this->b;

					while (true)
					{
						$this->a = $this->get();

						if ($this->a === NULL)
						{
							return NULL;
						}

						if ($this->a === '/')
						{
							break;
						} elseif ($this->a === '\\')
						{
							$this->output .= $this->a;
							$this->a			 = $this->get();
						} elseif (ord($this->a) <= $chr_lf)
						{
							return array('Unterminated regular expression literal.');
						}

						$this->output .= $this->a;
					}

					$this->b = $this->next();
					if (is_array($this->b)) return $this->b;
				}
		}

		return NULL;
	}

	/**
	 * Get the next stream token
	 *
	 * @return 	string		Next stream token
	 */
	function get()
	{
		$chr_space=32;

		$c = $this->lookAhead;
		$this->lookAhead = NULL;

		if ($c === NULL)
		{
			if ($this->inputIndex < $this->inputLength)
			{
				$c = $this->input[$this->inputIndex];
				$this->inputIndex += 1;
			} else
			{
				$c = NULL;
			}
		}

		if ($c === "\r")
		{
			return "\n";
		}

		if ($c === NULL || $c === "\n" || ord($c) >= $chr_space)
		{
			return $c;
		}

		return ' ';
	}

	/**
	 * Find whether a character is alphanumeric
	 *
	 * @param 	string		Character
	 * @return 	boolean		Whether it is
	 */
	function isAlphaNum($c)
	{
		if (is_null($c)) return false;
		return ord($c) > 126 || $c == '\\' || preg_match('/^[\w\$]$/', $c) == 1;
	}

	/**
	 * Do minification process
	 *
	 * @return 	string		Minified Javascript
	 */
	function min()
	{
		$this->a = "\n";
		$test = $this->action(3);
		if (is_array($test)) return $this->input; // Error

		while ($this->a !== NULL)
		{
			switch ($this->a)
			{
				case ' ':
					if ($this->isAlphaNum($this->b))
					{
						$test = $this->action(1);
						if (is_array($test)) return $this->input; // Error
					} else
					{
						$test = $this->action(2);
						if (is_array($test)) return $this->input; // Error
					}
					break;

				case "\n":
					switch ($this->b)
					{
						case '{':
						case '[':
						case '(':
						case '+':
						case '-':
							$test = $this->action(1);
							if (is_array($test)) return $this->input; // Error
							break;

						case ' ':
							$test = $this->action(3);
							if (is_array($test)) return $this->input; // Error
							break;

						default:
							if ($this->isAlphaNum($this->b))
							{
								$test = $this->action(1);
								if (is_array($test)) return $this->input; // Error
							}
							else
							{
								$test = $this->action(2);
								if (is_array($test)) return $this->input; // Error
							}
					}
					break;

				default:
					switch ($this->b)
					{
						case ' ':
							if ($this->isAlphaNum($this->a))
							{
								$test = $this->action(1);
								if (is_array($test)) return $this->input; // Error
								break;
							}

							$test = $this->action(3);
							if (is_array($test)) return $this->input; // Error
							break;

						case "\n":
							switch ($this->a)
							{
								case '}':
								case ']':
								case ')':
								case '+':
								case '-':
								case '"':
								case "'":
									$test = $this->action(1);
									if (is_array($test)) return $this->input; // Error
									break;

								default:
									if ($this->isAlphaNum($this->a))
									{
										$test = $this->action(1);
										if (is_array($test)) return $this->input; // Error
									}
									else
									{
										$test = $this->action(3);
										if (is_array($test)) return $this->input; // Error
									}
							}
							break;

						default:
							$test = $this->action(1);
							if (is_array($test)) return $this->input; // Error
							break;
					}
			}
		}

		return $this->output;
	}

	/**
	 * Get the next item in the stream
	 *
	 * @return 	mixed			Next item or error (array)
	 */
	function next()
	{
		$chr_lf=10;

		$c = $this->get();

		if ($c === '/')
		{
			switch($this->peek())
			{
				case '/':
					while (true)
					{
						$c = $this->get();

						if ($c === NULL)
						{
							return NULL;
						}

						if (ord($c) <= $chr_lf)
						{
							return $c;
						}
					}

				case '*':
					$this->get();

					while (true)
					{
						switch($this->get())
						{
							case '*':
								if ($this->peek() === '/')
								{
									$this->get();
									return ' ';
								}
								break;

							case NULL:
								return array('Unterminated comment.');
						}
					}

				default:
					return $c;
			}
		}

		return $c;
	}

	/**
	 * Find what's next in the stream
	 *
	 * @return 	string		What's next
	 */
	function peek()
	{
		$this->lookAhead = $this->get();
		return $this->lookAhead;
	}
}
